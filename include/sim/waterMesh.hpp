#pragma once

#include "frontend/shader.hpp"
#include "sim/waterSimulation.hpp"

#include <cstdint>
#include <linalg.h>

class Shader;

/**
 * @class WaterMesh
 * @brief Manages the OpenGL vertex data for rendering the dynamic water
 * surface.
 * @ingroup sim
 *
 * @details This class is specifically designed to render the 2D heightfield
 * generated by the `WaterSimulation`. It is distinct from the general-purpose
 * `frontend/Mesh` class because its vertex data, specifically the height and
 * normals, must be updated every frame.
 *
 * @section Technicality
 * The core design is a significant performance optimization for dynamic
 * geometry. Instead of a single, interleaved vertex buffer, the mesh data is
 * split across multiple Vertex Buffer Objects (VBOs):
 * - **`positionVBO`:** Stores the static (x, z) coordinates of the grid
 * vertices. This buffer is created once at initialisation and never modified,
 * which is efficient as this data does not need to be resent to the GPU.
 * - **`heightVBO`:** Stores the dynamic y-coordinate (height) for each vertex.
 * This buffer is updated every frame.
 * - **`normalVBO`:** Stores the dynamic normal vector for each vertex, which is
 * recalculated each frame based on the new heights.
 *
 * This separation allows the `updateMesh` function to only resubmit the small
 * subset of data that actually changes (heights and normals) using
 * `glBufferSubData`. This is much faster than recreating and resubmitting the
 * entire set of vertex attributes for the whole mesh each frame.
 *
 * @section Rendering with a Geometry Shader
 * The mesh is drawn using the `GL_LINES_ADJACENCY` primitive topology. This
 * primitive is used to pass the four vertices of each grid quad to the
 * **geometry shader**. The geometry shader is responsible for dynamically
 * triangulating each quad on the GPU.
 *
 * This process uses a technique known as **adaptive triangulation** or
 * "diagonal flipping" to reduce visual silhouette artefacts. For each quad, the
 * shader compares the sum of heights of the two possible diagonals. It selects
 * the diagonal that better aligns with the wave crests by picking the one
 * connecting the two lower vertices. Specifically, it chooses the diagonal \f$
 * (i, j) - (i+1, j+1) \f$ if \f$ \eta_{i,j} + \eta_{i+1,j+1} > \eta_{i+1,j} +
 * \eta_{i,j+1} \f$, and the opposite diagonal otherwise.
 *
 * After determining the optimal diagonal, the geometry shader emits two
 * triangles to form the quad, effectively constructing the water surface
 * on-the-fly. This GPU-based approach is highly efficient and results in a more
 * visually pleasing water surface that better represents the underlying wave
 * patterns. The shader also computes a per-triangle "roughness" value based on
 * local height variation, which is passed to the fragment shader for advanced
 * lighting.
 *
 * This technique was implemented according to Matthias MÃ¼ller-Fischer's 2007
 * paper, "Real-Time Simulation of Large Bodies of Water with Small Scale
 * Details", section 3.
 *
 * @section Algorithms
 * The `computeNormals` method calculates per-vertex normals on the CPU. For
 * each vertex, it approximates the surface normal by taking the cross product
 * of two vectors formed by its immediate neighbours on the grid. This is a
 * standard finite difference approach to calculating normals for a heightfield.
 * These normals are crucial for achieving realistic lighting on the water
 * surface.
 */
class WaterMesh
{
    /** @brief The number of grid rows, matching the simulation. */
    constexpr static size_t numRows = WaterSimulation::numRows;
    /** @brief The number of grid columns, matching the simulation. */
    constexpr static size_t numCols = WaterSimulation::numCols;
    /** @brief The size of each grid cell, matching the simulation. */
    constexpr static float cellSize = WaterSimulation::cellSize;
    /** @brief The world-space corner of the grid, matching the simulation. */
    constexpr static linalg::aliases::float2 bottomLeftCornerWorldPos_xz = {
      WaterSimulation::bottomLeftCornerWorldPos_xz.x,
      WaterSimulation::bottomLeftCornerWorldPos_xz.y};

    /** @brief The OpenGL Vertex Array Object (VAO) handle. */
    uint32_t VAO{0};
    /** @brief The VBO handle for static (x, z) vertex positions. */
    uint32_t positionVBO{0};
    /** @brief The VBO handle for dynamic (y) vertex heights. */
    uint32_t heightVBO{0};
    /** @brief The VBO handle for dynamic vertex normals. */
    uint32_t normalVBO{0};
    /** @brief The Index Buffer Object (IBO) handle for drawing quad patches. */
    uint32_t indexBuffer{0};

    /** @brief A CPU-side array of the static (x, z) positions of the mesh
     * vertices. */
    std::array<linalg::aliases::float2,
               numRows * numCols>
      staticPositions; // x, z positions

    /** @brief A CPU-side array of indices used to define the quad patches for
     * tessellation. */
    std::array<uint32_t, (numRows - 1) * (numCols - 1) * 4> indices;

    /** @brief A CPU-side array for storing the dynamically computed vertex
     * normals. */
    std::array<linalg::aliases::float3, numRows * numCols> normals;

    /**
     * @brief Computes the per-vertex normals for the entire mesh based on the
     * current heightfield.
     * @param heights An array of the current water heights for each vertex.
     */
    void computeNormals(const std::array<float, numRows * numCols>& heights);

  public:
    /**
     * @brief Constructs the WaterMesh, generating the static grid data and
     * initializing OpenGL buffers.
     */
    explicit WaterMesh();

    /** @brief Deleted copy constructor. */
    WaterMesh(const WaterMesh&) = delete;
    /** @brief Deleted move constructor. */
    WaterMesh(WaterMesh&&) = delete;
    /** @brief Deleted copy assignment operator. */
    WaterMesh& operator=(const WaterMesh&) = delete;
    /** @brief Deleted move assignment operator. */
    WaterMesh& operator=(WaterMesh&&) = delete;

    /**
     * @brief Destructor that cleans up and releases all OpenGL buffer objects
     * and the VAO.
     */
    ~WaterMesh();

    /**
     * @brief Updates the dynamic OpenGL buffers with new height and normal
     * data.
     * @param heights The new heightfield data from the water simulation.
     */
    void updateMesh(const std::array<float, numRows * numCols>& heights);

    /**
     * @brief Renders the water mesh.
     * @param shader The shader program to use for rendering.
     * @param cameraPos The position of the camera in world space, for lighting
     * calculations.
     */
    void draw(Shader::BindObject& shader,
              const linalg::aliases::float3& cameraPos) const;
};
